name: CI/CD Pipeline

on:
  push:
    branches:
    - main
  pull_request:
    branches:
    - main

jobs:
  build:
    runs-on: self-hosted

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Minikube
      uses: medyagh/setup-minikube@latest

    - name: Install Istio CLI
      run: |
        curl -L https://istio.io/downloadIstio | sh -
        sudo mv istio-*/bin/istioctl /usr/local/bin/

    - name: Install Istio in Minikube
      run: |
        istioctl install --set profile=demo -y
        kubectl label namespace default istio-injection=enabled

    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_PAT }}

    - name: Build image
      run: |
        VERSION=$GITHUB_REF_NAME
        echo "Building Docker image with tag: nishantrepo/goapp:${VERSION}"
        docker build -t nishantrepo/goapp:$VERSION .
        docker push nishantrepo/goapp:$VERSION

    - name: Deploy to Kubernetes
      env:
        VERSION: ${{ github.ref_name }}
      run: |
        VERSION=$GITHUB_REF_NAME

        kubectl config set-context minikube

        yq e 'select(.kind == "Deployment") | .metadata.name = "myapp-" + env(VERSION)' -i ./deploy.yaml
        yq e 'select(.kind == "Deployment") | .spec.template.spec.containers[0].image = "nishantrepo/goapp:" + env(VERSION)' -i ./deploy.yaml

        echo "Deploying to Kubernetes with version ${VERSION}"

        kubectl apply -f ./deploy.yaml
        kubectl apply -f ./service.yaml
        sleep 60

        kubectl get pods

        kubectl wait --for=condition=ready pod -l app=myapp --timeout=600s

    - name: Retrieve and Print Service URL
      run: |
        EXTERNAL_IP=$(kubectl get svc myapp-${VERSION} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
        if [ -z "$EXTERNAL_IP" ]; then
          NODE_PORT=$(kubectl get svc myapp-${VERSION} -o jsonpath='{.spec.ports[0].nodePort}')
          NODE_IP=$(minikube ip)
          EXTERNAL_URL="http://$NODE_IP:$NODE_PORT"
        else
          EXTERNAL_URL="http://$EXTERNAL_IP"
        fi

        if [ -z "$EXTERNAL_URL" ]; then
          echo "Service URL could not be determined."
          exit 1
        else
          echo "Your service is accessible at: $EXTERNAL_URL/"
        fi

    - name: Install ngrok
      run: |
        curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null &&
        echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list &&
        sudo apt update && sudo apt install ngrok

    - name: Login to ngrok
      run: |
        ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}

    - name: Expose Minikube service using ngrok
      run: |
        NODE_PORT=$(kubectl get svc myapp-${VERSION} -o jsonpath='{.spec.ports[0].nodePort}')
        echo "Starting ngrok on port $NODE_PORT"
        nohup ngrok http $NODE_PORT --log=stdout > ngrok.log &
        sleep 10 # Wait for ngrok to start
        NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
        if [ -z "$NGROK_URL" ]; then
          echo "ngrok URL could not be retrieved."
          exit 1
        else
          echo "Your ngrok URL is: $NGROK_URL"
        fi
