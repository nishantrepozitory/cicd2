name: CI/CD Pipeline

# on:
#   pull_request:
#     types: [labeled]
#     branches:
#     - main
on:
  push:
    branches:
    - main
  pull_request:
    branches:
    - main

jobs:
  build:
    # if: contains(github.event.pull_request.labels.*.name, 'qa-env')
    runs-on: ubuntu-latest
    permissions: write-all
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Minikube
      uses: medyagh/setup-minikube@latest

    - name: Install Istio CLI
      run: |
        if ! command -v istioctl &> /dev/null; then
          curl -L https://istio.io/downloadIstio | sh -
          sudo mv istio-*/bin/istioctl /usr/local/bin/
        else
          echo "Istio CLI already installed."
        fi
      continue-on-error: true

    - name: Install Istio in Minikube
      run: |
        if ! kubectl get namespace istio-system &> /dev/null; then
          istioctl install --set profile=demo -y
          kubectl label namespace default istio-injection=enabled --overwrite
        else
          echo "Istio already installed."
        fi

    # - name: Login to Docker Hub
    #   uses: docker/login-action@v2
    #   with:
    #     username: ${{ secrets.DOCKER_HUB_USERNAME }}
    #     password: ${{ secrets.DOCKER_HUB_PAT }}

    # - name: Build Image
    #   run: |
    #     VERSION=${{ github.ref_name }}
    #     docker buildx create --use
    #     docker buildx build --cache-from=type=local,src=/tmp/.buildx-cache \
    #       --cache-to=type=local,dest=/tmp/.buildx-cache-new \
    #       -t nishantrepo/goapp:$VERSION --push .
    #     mv /tmp/.buildx-cache-new /tmp/.buildx-cache

    - name: Check if Lock is Set
      uses: github/lock@v2.3.0
      id: check_lock
      with:
        mode: check
        environment: develop

    - name: Check Lock Status (with retries)
      id: check_lock_status
      run: |
        max_retries=3
        retry_count=0
        lock_status="locked"

        while [[ $retry_count -lt $max_retries && $lock_status == "locked" ]]; do
          echo "Checking if lock is set (attempt $((retry_count + 1)))..."

          # Check lock status
          lock_status=$(gh run list --workflow-lock --limit 1 | grep 'locked' || echo "locked")

          if [[ $lock_status == "locked" ]]; then
            echo "Lock is currently held, waiting..."
            sleep 20  # Wait 20 seconds between checks
          else
            echo "Lock is not held."
            break
          fi

          retry_count=$((retry_count + 1))
        done

        if [[ $lock_status == "locked" ]]; then
          echo "Lock is still held after $max_retries retries. Failing the job..."
          exit 1
        fi

    - name: Acquire Lock
      uses: github/lock@v2.3.0
      id: acquire_lock
      with:
        mode: lock
        environment: develop

    - name: Update VirtualService File with Commit Hash
      run: |
        COMMIT_HASH=${{ github.sha }}
        yq eval 'select(.kind == "VirtualService").spec.http[0].route[0].destination.version =  "'"$COMMIT_HASH"'"' -i virtualService.yaml
        kubectl apply -f ./virtualService.yaml

    - name: Unlock
      uses: github/lock@v2.3.0
      id: unlock
      with:
        mode: unlock
        environment: develop

    - name: Deploy to Kubernetes
      env:
        VERSION: ${{ github.ref_name }}
      run: |
        kubectl config use-context minikube
        yq eval 'select(.kind == "Deployment").metadata.name = "myapp-" + env(VERSION)' -i ./deploy.yaml
        yq eval 'select(.kind == "Deployment").spec.template.spec.containers[0].image = "nishantrepo/goapp:" + env(VERSION)' -i ./deploy.yaml

        echo "Deploying to Kubernetes with version ${VERSION}"
        kubectl apply -f ./deploy.yaml -f ./service.yaml
        kubectl wait --for=condition=available --timeout=60s deployment/myapp-${VERSION}

    - name: Retrieve and Print Service URL
      run: |
        EXTERNAL_IP=$(kubectl get svc myapp -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
        if [ -z "$EXTERNAL_IP" ]; then
          NODE_PORT=$(kubectl get svc myapp -o jsonpath='{.spec.ports[0].nodePort}')
          NODE_IP=$(minikube ip)
          EXTERNAL_URL="http://$NODE_IP:$NODE_PORT"
        else
          EXTERNAL_URL="http://$EXTERNAL_IP"
        fi

        if [ -z "$EXTERNAL_URL" ]; then
          echo "Service URL could not be determined."
          exit 1
        else
          echo "Your service is accessible at: $EXTERNAL_URL/"
        fi

    - name: Install ngrok
      run: |
        curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null &&
        echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list &&
        sudo apt update && sudo apt install ngrok

    - name: Login to ngrok
      run: |
        ngrok config add-authtoken ${{ secrets.NGROK_AUTH_TOKEN }}

    - name: Expose Minikube service using ngrok
      run: |
        NODE_PORT=$(kubectl get svc myapp -o jsonpath='{.spec.ports[0].nodePort}')
        echo "Starting ngrok on port $NODE_PORT"
        nohup ngrok http $NODE_PORT --log=stdout > ngrok.log &
        sleep 10 # Wait for ngrok to start
        NGROK_URL=$(curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[0].public_url')
        if [ -z "$NGROK_URL" ]; then
          echo "ngrok URL could not be retrieved."
          exit 1
        else
          echo "Your ngrok URL is: $NGROK_URL"
          sleep 1000
        fi
