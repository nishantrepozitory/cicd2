name: CI/CD Pipeline

on:
  push:
    branches:
    - main
  pull_request:
    branches:
    - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Minikube
      uses: medyagh/setup-minikube@latest

    # - name: Install Istio CLI
    #   run: |
    #     curl -L https://istio.io/downloadIstio | sh -
    #     sudo mv istio-*/bin/istioctl /usr/local/bin/
    #     istioctl version

    # - name: Install Istio in Minikube
    #   run: |
    #     istioctl install --set profile=demo -y
    #     kubectl label namespace default istio-injection=enabled
    #     sleep 60

    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_PAT }}

    - name: Build image
      run: |
        docker build -t nishantrepo/goapp:2.0.0 .
        docker push nishantrepo/goapp:2.0.0


    - name: Deploy to Kubernetes
      run: |
        kubectl config set-context minikube
        kubectl apply -f ./deploy.yaml
        kubectl apply -f ./service.yaml
        kubectl wait --for=condition=ready pod -l app=myapp --timeout=600s

    - name: Get Event
      run: |
        kubectl get events --sort-by=.metadata.creationTimestamp

    - name: Get Pod Logs
      run: |
        POD_NAME=$(kubectl get pods -l app=myapp -o jsonpath='{.items[0].metadata.name}')
        kubectl logs $POD_NAME

    - name: Check Pod Status
      run: |
        kubectl get pods -o wide

    - name: Describe Service
      run: |
        kubectl describe svc myapp

    - name: Wait for Service to be Available
      run: |
        echo "Waiting for service 'myapp' to be available..."
        kubectl wait --for=condition=available --timeout=60s svc/myapp

    - name: Retrieve and Print Service URL
      run: |
        # Check if service is exposed via LoadBalancer
        EXTERNAL_IP=$(kubectl get svc myapp -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
        if [ -z "$EXTERNAL_IP" ]; then
          # Fallback to NodePort if LoadBalancer is not available
          NODE_PORT=$(kubectl get svc myapp -o jsonpath='{.spec.ports[0].nodePort}')
          NODE_IP=$(minikube ip)
          EXTERNAL_URL="http://$NODE_IP:$NODE_PORT"
        else
          EXTERNAL_URL="http://$EXTERNAL_IP"
        fi

        if [ -z "$EXTERNAL_URL" ]; then
          echo "Service URL could not be determined."
          exit 1
        else
          echo "Your service is accessible at: $EXTERNAL_URL/"
        fi
